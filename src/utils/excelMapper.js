 /**
 * Generate unique code for asset
 * Format: TYPE + sequential number (GD001, KD001, BR001, etc)
 * @param {string} type - Asset type: 'gedung', 'kendaraan', 'barang'
 * @param {number} index - Sequential index for this type in current batch
 * @returns {string} Generated code
 */
function generateCode(type, index) {
    const typePrefix = {
        'gedung': 'GD',
        'kendaraan': 'KD',
        'barang': 'BR'
    };
    const prefix = typePrefix[type] || 'AS';
    const num = String(index).padStart(4, '0');
    return prefix + num;
}

/**
 * Map Excel columns to Asset schema fields
 * Handles flexible column names and infers asset type
 */

const FIELD_MAPPING = {
    code: ['Code', 'Kode', 'ID', 'No'],
    type: ['Type', 'Jenis BMN', 'Jenis', 'Kategori'],
    name: ['Name', 'Nama', 'Nama Asset', 'Nama Gedung', 'Nama Kendaraan', 'Nama Barang', 'Nama Item'],
    barcode: ['Kode Barang', 'No Barang', 'Kode Inventaris'],
    itemName: ['Nama Barang', 'Nama Item'],
    status: ['Status Penggunaan', 'Status', 'Status BMN'],
    merk: ['Merk', 'Brand'],
    tipe: ['Tipe', 'Model', 'Tipe/Model'],
    kondisi: ['Kondisi', 'Condition'],
    umur: ['Umur Aset', 'Tahun Pembuatan'],
    nup: ['NUP', 'Nomor Urut Perolehan'],
    lokasi: ['Alamat', 'Lokasi', 'Lokasi Ruang'],
};

/**
 * Find header column index by flexible mapping
 * @param {Array} headers - Row of headers from Excel
 * @param {Array} aliases - Possible column names
 * @returns {number|null} Column index or null
 */
function findColumnIndex(headers, aliases) {
    for (const alias of aliases) {
        const index = headers.findIndex(h => 
            h && h.trim().toLowerCase() === alias.toLowerCase()
        );
        if (index !== -1) return index;
    }
    return null;
}

/**
 * Infer asset type from data
 * @param {object} data - Parsed row data
 * @returns {string} 'gedung', 'kendaraan', or 'barang'
 */
function inferAssetType(data) {
    const typeStr = (data.type || '').toLowerCase();
    
    // Check explicit type indicators
    if (typeStr.includes('gedung') || typeStr.includes('bangunan') || typeStr.includes('ruangan')) {
        return 'gedung';
    }
    if (typeStr.includes('kendaraan') || typeStr.includes('mobil') || typeStr.includes('motor') || typeStr.includes('kendaraan dinas')) {
        return 'kendaraan';
    }
    if (typeStr.includes('barang') || typeStr.includes('peralatan') || typeStr.includes('equipment')) {
        return 'barang';
    }
    
    // Default to barang (most common)
    return 'barang';
}

/**
 * Parse Excel row and map to Asset schema
 * @param {Array} row - Raw Excel row
 * @param {Array} headers - Headers from Excel
 * @param {object} options - Options like { autoGenerateCode: true, index: 1 }
 * @returns {object} Mapped asset data
 */
function mapExcelRowToAsset(row, headers, options = {}) {
    const data = {};
    
    // Map each field
    const codeIdx = findColumnIndex(headers, FIELD_MAPPING.code);
    const typeIdx = findColumnIndex(headers, FIELD_MAPPING.type);
    const nameIdx = findColumnIndex(headers, FIELD_MAPPING.name);
    const merkIdx = findColumnIndex(headers, FIELD_MAPPING.merk);
    const tipeIdx = findColumnIndex(headers, FIELD_MAPPING.tipe);
    const kondisiIdx = findColumnIndex(headers, FIELD_MAPPING.kondisi);
    const statusIdx = findColumnIndex(headers, FIELD_MAPPING.status);
    const lokasiIdx = findColumnIndex(headers, FIELD_MAPPING.lokasi);
    
    // Extract code (might be empty if auto-generate)
    data.code = codeIdx !== null ? String(row[codeIdx] || '').trim() : '';
    
    // Extract type
    data.type = typeIdx !== null ? String(row[typeIdx] || '').trim() : '';
    
    // Extract name - more flexible
    data.name = nameIdx !== null ? String(row[nameIdx] || '').trim() : '';
    
    // Infer type if not explicit
    data.type = inferAssetType(data);
    
    // Auto-generate code if empty and option enabled
    if (!data.code && options.autoGenerateCode && options.index !== undefined) {
        data.code = generateCode(data.type, options.index);
        data.isAutoGenerated = true;
    }
    
    // Collect additional details
    const details = [];
    if (merkIdx !== null && row[merkIdx]) {
        details.push(`Merk: ${row[merkIdx]}`);
    }
    if (tipeIdx !== null && row[tipeIdx]) {
        details.push(`Tipe: ${row[tipeIdx]}`);
    }
    if (kondisiIdx !== null && row[kondisiIdx]) {
        details.push(`Kondisi: ${row[kondisiIdx]}`);
    }
    if (statusIdx !== null && row[statusIdx]) {
        details.push(`Status: ${row[statusIdx]}`);
    }
    if (lokasiIdx !== null && row[lokasiIdx]) {
        details.push(`Lokasi: ${row[lokasiIdx]}`);
    }
    
    data.detail = details.join(' | ') || '';
    
    return data;
}

/**
 * Validate mapped asset
 * @param {object} asset - Mapped asset data
 * @param {object} options - Options like { allowEmptyName: true }
 * @returns {object} { valid: boolean, errors: Array }
 */
function validateAsset(asset, options = {}) {
    const errors = [];
    
    // Code: auto-generated or provided
    if (!asset.code || asset.code.length === 0) {
        errors.push('Code wajib ada (atau akan di-generate otomatis)');
    }
    
    // Name: bisa kosong atau dari field lain
    if (!asset.name || asset.name.length === 0) {
        if (!options.allowEmptyName) {
            errors.push('Name wajib ada (bisa dari kolom: Name, Nama, Nama Asset, dll)');
        }
    }
    
    // Type: harus valid
    if (!['gedung', 'kendaraan', 'barang'].includes(asset.type)) {
        errors.push(`Type invalid: ${asset.type} (harus: gedung, kendaraan, atau barang)`);
    }
    
    return {
        valid: errors.length === 0,
        errors
    };
}

module.exports = {
    generateCode,
    findColumnIndex,
    inferAssetType,
    mapExcelRowToAsset,
    validateAsset,
    FIELD_MAPPING
};
